freeze;
/****-*-magma-******a********************************************************
                                                                            
                        Algebraic Modular Forms in Magma
                        
                  E. Assaf, M. Greenberg, J. Hein, J.Voight
         using lattices over number fields by M. Kirschmer and D. Lorch         
                   
   FILE: fracIdl.m

   Fractional Ideal class (for the ring of integers)
  
   The purpose of this file is to create an identical interface 
   to that of fractional ideals over number fields, simplifying the code
   to handle both cases.

   04/16/2021: Created this file
 ***************************************************************************/

// Here we list the intrinsics that this file defines
// intrinsic FractionalIdeal(a::FldRatElt) -> RngIntFracIdl
// intrinsic FractionalIdeal(a::RngIntElt) -> RngIntFracIdl
// intrinsic FractionalIdeal(seq::SeqEnum) -> RngIntFracIdl
// intrinsic FractionalIdeal(seq::SeqEnum) -> RngIntFracIdl
// intrinsic '!!'(QQ::FldRat, I::RngOrdFracIdl) -> RngIntFracIdl
// intrinsic '!!'(QQ::FldRat, I::RngIntFracIdl) -> RngIntFracIdl
// intrinsic '^'(I::RngIntFracIdl, n::RngIntElt) -> RngIntFracIdl
// intrinsic Norm(I::RngIntFracIdl) -> RngIntElt
// intrinsic '*'(I::RngIntFracIdl, J::RngIntFracIdl) -> RngIntFracIdl
// intrinsic '+'(I::RngIntFracIdl, J::RngIntFracIdl) -> RngIntFracIdl
// intrinsic '*'(a::FldRatElt, I::RngIntFracIdl) -> RngIntFracIdl
// intrinsic '*'(a::RngIntElt, I::RngIntFracIdl) -> RngIntFracIdl
// intrinsic 'eq'(I::RngIntFracIdl, J::RngIntFracIdl) -> BoolElt
// intrinsic 'eq'(I::RngIntFracIdl, J::RngInt) -> BoolElt
// intrinsic IsIntegral(I::RngIntFracIdl) -> BoolElt
// intrinsic Factorization(I::RngIntFracIdl) -> SeqEnum
// intrinsic Basis(I::RngIntFracIdl) -> SeqEnum
// intrinsic Order(I::RngIntFracIdl) -> Rng
// intrinsic Valuation(I::RngIntFracIdl, p::RngInt) -> RngIntElt
// intrinsic Generators(I::RngIntFracIdl) -> SeqEnum
// intrinsic Print(I::RngIntFracIdl, level::MonStgElt)

declare type RngIntFracIdl;
declare attributes RngIntFracIdl:
  gen;

// Constructors

function idealConstructor(a)
  I := New(RngIntFracIdl);
  I`gen := a;
  return I;
end function;

intrinsic FractionalIdeal(a::FldRatElt) -> RngIntFracIdl
{Constructs the fractional ideal generated by a.}
  return idealConstructor(a); 
end intrinsic;

intrinsic FractionalIdeal(a::RngIntElt) -> RngIntFracIdl
{Constructs the fractional ideal generated by a.}
  return idealConstructor(a);
end intrinsic;

intrinsic FractionalIdeal(seq::SeqEnum) -> RngIntFracIdl
{Constructs the fractional ideal generated by the sequence seq.}
  nums := [Numerator(x) : x in seq];
  dens := [Denominator(x) : x in seq];
  return FractionalIdeal(GCD(nums) / LCM(dens));
end intrinsic;

// Coercion

function idealCoercion(I)
  J := New(RngIntFracIdl);
  J`gen := Norm(I);
  return J;
end function;

intrinsic FractionalIdeal(I::RngInt) -> RngIntFracIdl
{Make the ideal I a fractional ideal.}
  return idealCoercion(I);
end intrinsic;

intrinsic '!!'(QQ::FldRat, I::RngOrdFracIdl) -> RngIntFracIdl
{Make the ideal I a fractional ideal.}
  return idealCoercion(I);
end intrinsic;

intrinsic '!!'(QQ::FldRat, I::RngIntFracIdl) -> RngIntFracIdl
{Make the ideal I a fractional ideal.}
  return idealCoercion(I);
end intrinsic;

// arithmetic

intrinsic '^'(I::RngIntFracIdl, n::RngIntElt) -> RngIntFracIdl
{The n-th power of the fractional ideal I.}
  return FractionalIdeal(I`gen^n);
end intrinsic;

intrinsic '*'(I::RngIntFracIdl, J::RngIntFracIdl) -> RngIntFracIdl
{Multiply two fractional ideals.}
  L := New(RngIntFracIdl);
  L`gen := I`gen*J`gen;
  return L;
end intrinsic;

intrinsic '+'(I::RngIntFracIdl, J::RngIntFracIdl) -> RngIntFracIdl
{Add two fractional ideals.}
  return FractionalIdeal([I`gen, J`gen]);
end intrinsic;

function scalarMul(a, I)
  J := New(RngIntFracIdl);
  J`gen := a*I`gen;
  return J;
end function;

intrinsic '*'(a::FldRatElt, I::RngIntFracIdl) -> RngIntFracIdl
{Multiply a fractional ideal by a scalar.}
  return scalarMul(a, I);
end intrinsic;

intrinsic '*'(a::RngIntElt, I::RngIntFracIdl) -> RngIntFracIdl
{Multiply a fractional ideal by a scalar.}
  return scalarMul(a, I);
end intrinsic;

// boolean opertors

intrinsic 'eq'(I::RngIntFracIdl, J::RngIntFracIdl) -> BoolElt
{Returns true if I and J are the same fractional ideal.}
  return (I`gen eq J`gen) or (I`gen eq -J`gen);
end intrinsic;

intrinsic 'eq'(I::RngIntFracIdl, J::RngInt) -> BoolElt
{{Returns true if I and J are the same fractional ideal.}
  return I eq FractionalIdeal(J);
end intrinsic;

intrinsic IsIntegral(I::RngIntFracIdl) -> BoolElt
{Returns true if and only if the fractional ideal I is integral.}
  return IsIntegral(I`gen);
end intrinsic;

// access to different invariants

intrinsic Norm(I::RngIntFracIdl) -> RngIntElt
{The norm of the fraction ideal I.}
  return I`gen;
end intrinsic;
 
intrinsic Factorization(I::RngIntFracIdl) -> SeqEnum[Tup]
{Returns the prime ideal factorization of an ideal I , as a sequence of 2-tuples (prime ideal and integer exponent).}
  fac_num := Factorization(Numerator(I`gen));
  fac_denom := Factorization(Denominator(I`gen));
  fac := Sort(fac_num cat [<x[1], -x[2]> : x in fac_denom]);
  return [<ideal<Integers() | x[1]>, x[2]> : x in fac];
end intrinsic;

intrinsic Basis(I::RngIntFracIdl) -> SeqEnum[FldRatElt]
{Given an ideal I, this function returns a basis for I as a sequence of rational elements.}
  return [I`gen];
end intrinsic;

intrinsic Order(I::RngIntFracIdl) -> Rng
{The order O which the ideal I is of.}
  return Integers();
end intrinsic;

intrinsic Valuation(I::RngIntFracIdl, p::RngInt) -> RngIntElt
{Given a (fractional) ideal I and a prime ideal p, returns the
 valuation v_p(I) of I at p, that is, the number of factors p in the
 prime ideal decomposition of I.  Note that, since the ideal I is
 allowed to be a fractional ideal, the returned value may be a
 negative integer.}
  return Valuation(I`gen, p);
end intrinsic;

intrinsic Generators(I::RngIntFracIdl) -> SeqEnum[FldRatElt]
{Given a (fractional) ideal I, return a sequence containing
 elements that generate I as an ideal.  The elements will be rationals.}
  return [I`gen];
end intrinsic;

// Printing

intrinsic Print(I::RngIntFracIdl, level::MonStgElt)
{.}
  if (level eq "Magma") then
    printf "FractionalIdeal(%o)", I`gen;			  
  else			
    printf "Principal Ideal of Integer Ring\n";
    printf "Generator:\n";
    printf "%o", I`gen;
  end if;
end intrinsic;

